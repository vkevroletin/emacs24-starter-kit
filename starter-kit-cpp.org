
* General

- Open .h files in c++ mode. In theory c++ mode should handle c
  headers properly.
  #+begin_src emacs-lisp
    (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
  #+end_src

There are several important features required for development of big
programming project:

+ source code navigation
  - Gtags - tags-based navigation. Simple, not accurate but robust.

  - Semantic/Senator - navigation based on parsed implemented in Emacs
    lisp. It understands context. But not 100% accurate and quite
    fragile.

  - gcc/clang based parsers - should be more accurate. Didn't
    investigate them.

+ code completion
  - auto-complete, hippie-expand - not accurate completion which
    cache strings from current buffer. Extremely simple and not very
    useful for c++ development.

  - Semantic - let's investigate.

  - gcc/clang -  should be very accurate. Didn't investigate them.

+ string search through project files
  - projectile and helm helps to quickly grep through project files.

  - Gtags allows to quickly search tags.

  - Semantic allows to find tags and references to particular tag.

+ quick files switch
  - projectile and helm provide interactive interface to find files by
    names.

+ refactoring

  Didn't investigate.

** Run common programming hooks

#+begin_src emacs-lisp
  (add-hook 'c-mode-hook 'run-starter-kit-coding-hook)
  (add-hook 'c++-mode-hook 'run-starter-kit-coding-hook)
#+end_src

** Compilation

- By default C-c C-c is bound to comment-region which is not very
  usefull command. C-c C-c is super useful command in org-mode. Let's
  make is useful in c++ mode.

  #+begin_src emacs-lisp
    (require 'cc-mode)
    (define-key c-mode-map (kbd "C-c C-c") 'recompile)
    (define-key c++-mode-map (kbd "C-c C-c") 'recompile)
  #+end_src

* Gtags

** Configure

- Ignore case
  #+begin_src emacs-lisp
    (setq helm-gtags-ignore-case t)
  #+end_src

- Tag files are updated whenever a file is saved
  #+begin_src emacs-lisp
    (setq helm-gtags-auto-update t)
  #+end_src

- Use input at cursor
  #+begin_src emacs-lisp
    (setq helm-gtags-use-input-at-cursor t)
  #+end_src

- Pulse at point after jumping
  #+begin_src emacs-lisp
    (setq helm-gtags-pulse-at-cursor t)
  #+end_src

- Prefix key for gtags commands
  #+begin_src emacs-lisp
    (setq helm-gtags-prefix-key "\C-cg")
  #+end_src

- Enable default gtags mappings

  Search for helm-gtags-suggested-key-mapping in helm-gtags.el file
  for details.
  #+begin_src emacs-lisp
    (setq helm-gtags-suggested-key-mapping t)
  #+end_src

** Integrate with Helm

- Install ready package
  #+begin_src emacs-lisp
    (starter-kit-install-if-needed 'helm-gtags)
    (require 'helm-gtags)
  #+end_src

- Enable for several modes
  #+begin_src emacs-lisp
    (add-hook 'dired-mode-hook  'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook      'helm-gtags-mode)
    (add-hook 'c++-mode-hook    'helm-gtags-mode)
    (add-hook 'asm-mode-hook    'helm-gtags-mode)
  #+end_src

- Configure bindings
  #+begin_src emacs-lisp
    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-c g s") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
  #+end_src

* Speedbar

Same window speedbar
#+begin_src emacs-lisp
  (starter-kit-install-if-needed 'sr-speedbar)
#+end_src

* Semantic

[1]

- Load Semantic

  TODO: why do we load it at startup? How about lazy configuration?
  #+begin_src emacs-lisp
    (require 'cc-mode)
    (require 'semantic)
  #+end_src

** Configure

- Maintain tag database.
  #+begin_src emacs-lisp
    (global-semanticdb-minor-mode 1)
  #+end_src

- Reparse buffer when idle.
  #+begin_src emacs-lisp
    (global-semantic-idle-scheduler-mode 1)
  #+end_src

- Additional tag decorations.
  Useful to understand which includes already parsed by
  semantic.
  #+begin_src emacs-lisp
    (global-semantic-decoration-mode 1)
    (custom-set-faces
      '(semantic-tag-boundary-face ((t nil))))
  #+end_src

- Highlight the current tag.
  #+begin_src emacs-lisp
    (global-semantic-highlight-func-mode 1)
  #+end_src

- Show current fun in header line.
  #+begin_src emacs-lisp
    (global-semantic-stickyfunc-mode 1)
  #+end_src

- Don't show summary of tag at point.
  #+begin_src emacs-lisp
    (global-semantic-idle-summary-mode 0)
  #+end_src

- Don't Show completions when idle.
  #+begin_src emacs-lisp
    (global-semantic-idle-completions-mode 0)
  #+end_src

** Keybindings

- C-c j is semantic fast jump in any buffer
  Configure global key binding since semantic is enabled globally.
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-c j") 'semantic-ia-fast-jump)
  #+end_src

** Enable

  #+begin_src emacs-lisp
    (semantic-mode 1)
  #+end_src

* Ede

#+begin_src emacs-lisp
  (global-ede-mode t)
#+end_src

* Insert header guards

  You definitely know what is header guard. Here is example:
  #+begin_example
    #ifndef __SAMPLE_HEADER_H
    #define __SAMPLE_HEADER_H
  #+end_example

+ Generate and insert header guards. Inspired by code from [[http://www.emacswiki.org/emacs/AutoInsertHeaderGuards][Emacs wiki]].
  #+begin_src emacs-lisp
    (defun cpp--create-define-name (x)
      (let* ((case-fold-search nil)
             (name (upcase (replace-regexp-in-string "\\([A-Z]\\)" "_\\1" x))))
        (concat "__" name "_H")))

    (defun insert-cpp-header-guards ()
      (interactive)
      (when (buffer-file-name)
        (let*
            ((fName (file-name-nondirectory (file-name-sans-extension buffer-file-name)))
             (defName (cpp--create-define-name fName))
             (ifDef (concat "#ifndef " defName "\n#define " defName "\n\n\n")))
          (set-mark (point))
          (goto-char (point-min))
          (insert ifDef)
          (goto-char (point-max))
          (insert "\n#endif")
          (goto-char (point-min))
          (dotimes (i 3) (forward-line)))))
  #+end_src

+ Ask to insert guards after opening of empty header file. It will
  work in case of creating new file.
  #+begin_src emacs-lisp
    (defun insert-cpp-header-guard-if-buffer-empty ()
      (when (and (string-match ".h$" (buffer-name))
                 (= 0 (buffer-size))
                 (yes-or-no-p "Header file is empty. Create include guards?"))
        (insert-cpp-header-guards)))

    (add-hook 'c++-mode-hook 'insert-cpp-header-guard-if-buffer-empty)
  #+end_src


* References

[1] http://tuhdo.github.io/c-ide.html
[2] http://www.youtube.com/watch?v=Ib914gNr0ys
